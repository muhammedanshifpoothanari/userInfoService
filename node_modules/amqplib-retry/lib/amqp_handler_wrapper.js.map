{"version":3,"sources":["../src/amqp_handler_wrapper.js"],"names":[],"mappings":"aAAA,GAAM,GAAI,QAAQ,YAAR,CAAV,CACA,GAAM,SAAU,QAAQ,UAAR,CAAhB,CACA,GAAM,QAAS,QAAQ,UAAR,CAAf,CAEA;AACA,GAAM,iBAAkB,QAAlB,gBAAkB,CAAC,QAAD,CAAc,CACpC,GAAM,OAAQ,KAAK,GAAL,CAAS,CAAT,CAAY,QAAZ,CAAd,CACA,GAAI,MAAQ,GAAK,EAAL,CAAU,EAAtB,CAA0B,CACxB;AACA,MAAO,CAAC,CACT,CACD,MAAO,OAAQ,IAChB,CAPD,CASA,OAAO,OAAP,CAAiB,SAAU,OAAV,CAAmB,eAAnB,CAAoC,gBAApC,CAAsD,aAAtD,CAAqE,aAArE,CAAoF,WAApF,CAAiG,CAChH,GAAM,cAAe,QAAf,aAAe,CAAC,GAAD,CAAS,CAC5B,GAAI,CAAC,YAAY,aAAjB,CAAgC,CAC9B;AACA,MAAO,SACJ,KADI,CACE,CADF,EAEJ,IAFI,CAEC,iBAAM,cAAa,GAAb,CAAN,CAFD,CAGR,CAED,EAAE,QAAF,CAAW,GAAX,CAAgB,CAAE,WAAY,EAAd,CAAhB,EACA,EAAE,QAAF,CAAW,IAAI,UAAf,CAA2B,CAAE,QAAS,EAAX,CAA3B,EACA,EAAE,QAAF,CAAW,IAAI,UAAJ,CAAe,OAA1B,CAAmC,CAAE,YAAa,CAAf,CAAnC,EAAuD;AAEvD,IAAI,UAAJ,CAAe,OAAf,CAAuB,WAAvB,EAAsC,CAAtC,CACA,GAAM,YAAa,CAAC,eAAiB,eAAlB,EAAmC,IAAI,UAAJ,CAAe,OAAf,CAAuB,WAA1D,CAAnB,CAEA,GAAI,WAAa,CAAjB,CAAoB,CAClB,MAAO,SAAQ,WAAR,CAAoB,gBAApB,CAAsC,GAAI,OAAJ,CAAW,IAAI,OAAf,CAAtC,CAA+D,IAAI,UAAnE,CACR,CAED,GAAM,YAAa,CACjB,WAAY,IADK,CAEjB,QAAS,CACP,oBAAqB,IAAI,UADlB,CAC8B;AACrC,aAAc,eAAgB;AAFvB,CAFQ,CAAnB,CAQA,EAAE,MAAF,CAAS,UAAT,CAAqB,CACnB,WAAY,WAAW,QAAX,EADO,CAArB,EAIA,MAAO,SAAQ,OAAR,CAAgB,EAAhB,CAAoB,OAAO,cAA3B,CAA2C,GAAI,OAAJ,CAAW,IAAI,OAAf,CAA3C,CAAoE,UAApE,CACR,CAhCD,CAkCA,GAAM,gBAAiB,QAAjB,eAAiB,CAAC,GAAD,QACrB,SACG,GADH,CACO,iBAAM,eAAc,GAAd,CAAN,CADP,EAEG,KAFH,CAES,SAAC,GAAD,CAAS,CACd;AACA;AACA,QAAQ,KAAR,CAAc,wDAAd,CAAwE,GAAxE,EACA,MAAO,SACJ,GADI,CACA,iBAAM,cAAa,GAAb,CAAN,CADA,EAEJ,KAFI,CAEE,SAAC,GAAD,CAAS,CACd;AACA;AACA,QAAQ,IAAR,CAAa,GAAb,EACA,KAAM,IACP,CAPI,CAQR,CAdH,EAeG,IAfH,CAeQ,iBACJ;AACA;AACA,QAAQ,GAAR,CAAY,GAAZ,CAHI,EAfR,CADqB,CAAvB,CAsBA,MAAO,eACR,CA1DD","file":"amqp_handler_wrapper.js","sourcesContent":["const _ = require('underscore')\nconst Promise = require('bluebird')\nconst config = require('./config')\n\n// attempts must be a number in milliseconds\nconst getDefaultDelay = (attempts) => {\n  const delay = Math.pow(2, attempts)\n  if (delay > 60 * 60 * 24) {\n    // the delay for the message is longer than 24 hours.  Fail the message and never retry again.\n    return -1\n  }\n  return delay * 1000\n}\n\nmodule.exports = function (channel, clientQueueName, failureQueueName, clientHandler, delayFunction, initializer) {\n  const errorHandler = (msg) => {\n    if (!initializer.isInitialized) {\n      // Delay in 1 MS to let the queues/exchange/bindings initialize\n      return Promise\n        .delay(1)\n        .then(() => errorHandler(msg))\n    }\n\n    _.defaults(msg, { properties: {} })\n    _.defaults(msg.properties, { headers: {} })\n    _.defaults(msg.properties.headers, { _retryCount: 0 }) // _retryCount: 0 means this message has never been retried before.\n\n    msg.properties.headers._retryCount += 1\n    const expiration = (delayFunction || getDefaultDelay)(msg.properties.headers._retryCount)\n\n    if (expiration < 1) {\n      return channel.sendToQueue(failureQueueName, new Buffer(msg.content), msg.properties)\n    }\n\n    const properties = {\n      persistent: true,\n      headers: {\n        _originalProperties: msg.properties, // save the original properties.\n        _targetQueue: clientQueueName // save the target queue name we should publish to after the delay is over.\n      }\n    }\n\n    _.extend(properties, {\n      expiration: expiration.toString()\n    })\n\n    return channel.publish('', config.delayQueueName, new Buffer(msg.content), properties)\n  }\n\n  const handlerWrapper = (msg) =>\n    Promise\n      .try(() => clientHandler(msg))\n      .catch((err) => {\n        // Something went wrong. Let's handle this message.\n        // Adding the string 'error' to support papertrail error filters.\n        console.error('Error: AMQP retry handler caught the following error: ', err)\n        return Promise\n          .try(() => errorHandler(msg))\n          .catch((err) => {\n            // Something went wrong while trying to process the erroneous message.\n            // Sending nack so the client can try to process it again.\n            channel.nack(msg)\n            throw err\n          })\n      })\n      .then(() =>\n        // We ack it for the user. Either way if the message has been processed successfully or\n        // not, the message should be out of the original queue, therefore - acked.\n        channel.ack(msg)\n      )\n\n  return handlerWrapper\n}\n\n"]}